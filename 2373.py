# coding: utf-8
"""
난이도 : 10

문제 : 정수 N이 주어진다. (2<=N<=1,000,000)
N개의 구슬에 대해 1번 사람이 N개 미만의 구슬을 가져갈 수 있고, 그다음 2번 사람이 전에 가져간 개수의 2배 이하를 가져갈 수 있는 게임이 있다.
1번 사람이 처음에 몇개의 구슬을 가져가면 반드시 이길지 개수를 구하는 문제. (가능한 경우가 여러 가지라면 더 적은 수의 구슬 개수를 출력)

알고리즘 : N개의 구슬에 순차적으로 놓고 규칙성을 찾아야 하는 문제이다.
규칙 1. N이 피보나치 수일 때 1번 사람은 반드시 진다. -> -1 출력
규칙 2. N이 피보나치 수가 아닐 때, N 보다 작은 수중에서 가장 큰 피보나치 수를 뺀 만큼의 구슬을 가져가면 1번 사람이 승리한다.
이를 토대로 알고리즘을 짜보자.
N은 최대 100만 까지이므로 30개짜리 피보나치 수열을 fibo_list에 넣는다. (30번째 수가 130만쯤 된다.)
N을 입력받고, first_N에 넣는다.
while문을 돌면서,
  for문을 이용해 N보다 작은 수 중, 가장 큰 피보나치 수를 temp에 넣는다.
if, 그런 피보나치 수 가 없으면, N은 피보나치 수라는 의미이며, N==temp가 된다. -> while문 종료 
아닌 경우(그런 피보나치 수가 있는 경우) N에서 temp만큼을 빼준다. (N보다 작은 수중 가장 큰 피보나치수를 빼준다.)
-> 그리고 다시 while 문 돌기 -> 그러면 N보다 작은 수중 가장 큰 피보나치수를 계속해서 빼가며 N이 피보나치수가 될때까지 while문이 돈다.

최종 적으로, N이 초기N 값인 first_N과 같다면, 즉, N이 피보나치 수 였다면 -1을 출력하고,
그게 아닌 경우 N을 출력 -> 여기서 N은 N보다 작은 수중 가장 큰 피보나치수를 계속해서 빼낸 값이다.
"""
def fib(n):
    fibs = [1,1]
    for i in range(2,n+1):
        fibs.append(fibs[-1] + fibs[-2])
    return fibs

N = int(input())

fibo_list = fib(30)
first_N = N
while 1:
    for i in range(len(fibo_list)):
        temp=N
        if temp < fibo_list[i]:
            temp = fibo_list[i-1] # N은 최소 2 이상
            break
    if N==temp: # N이 N보다 작은 피보나치 수를 빼서 피보나치 수가 되면 -> 최종적으로 그 N 만큼 1번 사람이 가져가는게 승리
        break
    N -= temp

print(-1 if N==first_N else N)